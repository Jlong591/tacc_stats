#!/opt/apps/python/2.7.1/bin/python
#tacc_stats_extract
import argparse, os, signal, string, sys, time
signal.signal(signal.SIGPIPE, signal.SIG_DFL)

SF_SCHEMA_CHAR = '!'
SF_DEVICES_CHAR = '@'
SF_COMMENT_CHAR = '#'
SF_PROPERTY_CHAR = '$'
SF_MARK_CHAR = '%'

prog = os.path.basename(sys.argv[0])

opt_parser = argparse.ArgumentParser(description="Extract data from stats file(s).", prog=prog)
# epilog=""
opt_parser.add_argument("-j", "--jobid", dest="jobid")
opt_parser.add_argument("-f", "--fqdn", "--full-hostname", action="store_true", dest="fqdn")
opt_parser.add_argument("-m", "--marks", action="store_true", dest="marks")
opt_parser.add_argument("-t", "--time-fmt", metavar="FMT", dest="time_fmt", default="%b %d %H:%M:%S")
opt_parser.add_argument("-v", "--verbose", action="store_true", dest="verbose")
# prefix time,host,jobid,type,dev
# fs, rs
# size_format

(opt, args) = opt_parser.parse_known_args()
spec_args = args
path_list = []
if "--" in args:
    spec_args = args[:args.index("--")]
    path_list = args[args.index("--") + 1:]

def trace(fmt, *args):
    if opt.verbose:
        msg = fmt % args
        sys.stderr.write(prog + ": " + msg)

def error(fmt, *args):
    msg = fmt % args
    sys.stderr.write(prog + ": " + msg)
    
def fatal(fmt, *args):
    msg = fmt % args
    sys.stderr.write(prog + ": " + msg)
    sys.exit(1)

trace("args: `%s'\n", args)
trace("opt: `%s'\n", opt)
trace("spec_args: `%s'\n", spec_args)
trace("path_list: `%s'\n", path_list)

if len(spec_args) == 0:
    fatal("must specify a type\n")

extract_type = spec_args[0]
extract_devs = None
extract_keys = None

if len(spec_args) >= 2 and spec_args[1] != '-':
    extract_devs = {}
    for dev in spec_args[1].split(','):
        extrace_devs[dev] = True

if len(spec_args) > 2:
    extract_keys = spec_args[2:]

class StatsType:
    def __init__(name):
        self.name = name
    def schema_init(spec):
        pass
    def handle(host, time, jobid, dev, vals):
        pass

def handle_mark(host, time, jobid, str):
    pass # TODO

def stats_file_read(sf):
    sf_type_dict = {}
    sf_prop_dict = {}
    # Read header.
    for line in sf:
        c = line[0]
        if c == SF_SCHEMA_CHAR:
            (name, spec) = line[1:].split(" ", 1)
            if name in sf_type_dict:
                st = sf_type_dict[name]
                st.schema_init(spec)
            else:
                st = StatsType(name)
                st.schema_init(spec)
                sf_type_dict[name] = st
        elif c == SF_DEVICES_CHAR:
            pass # Not implemented.
        elif c == SF_COMMENT_CHAR:
            pass
        elif c == SF_PROPERTY_CHAR:
            (key, val) = line[1:].split(" ", 1)
            sf_prop_dict[key] = val
        else:
            break
    # End of header.
    sf_host = sf_prop_dict.get("hostname")
    if not sf_host:
        error("no hostname found in `%s'\n", sf.name)
    # Read record groups.
    rg_time = 0
    rg_jobid = 0
    for line in sf:
        if line.isspace(): # End group.
            continue
        c = line[0]
        if c.isdigit(): # Begin group.
            r = line.split()
            rg_time = long(r[0])
            if len(r) > 1:
                rg_jobid = r[1]
        elif c.isalpha():
            r = line.split()
            st = sf_type_dict.get(r[0])
            if not st:
                error("unknown type `%s'\n", type)
                continue
            st.handle(sf_host, rg_time, rg_jobid, r[1], map(long, r[2:]))
        elif c == SF_COMMENT_CHAR:
            pass
        elif c == SF_MARK_CHAR:
            handle_mark(sf_host, rg_time, rg_jobid, line[1:])
        else:
            error("invalid record `%s'\n", line)
    # End record groups.

if len(path_list) == 0:
    stats_file_read(sys.stdin)
else:
    for path in path_list:
        stats_file_read(open(path, mode="r"))
