#!/usr/bin/python
#tacc_stats_extract
import sys, signal, string, time
signal.signal(signal.SIGPIPE, signal.SIG_DFL)

prog = sys.argv[0]
stats_file = sys.stdin
# time_fmt = "%b %d %H:%M"
time_fmt = "%s"
opt_format_size = False
opt_print_mark = False
hostname = "-"
opt_short_hostname = True
header_props = {}

SF_SCHEMA_CHAR = '!'
SF_DEVICES_CHAR = '@'
SF_COMMENT_CHAR = '#'
SF_PROPERTY_CHAR = '$'
SF_MARK_CHAR = '%'

def trace(fmt, *args):
    # msg = fmt % args
    # sys.stderr.write(prog + ": " + msg)
    pass

def error(fmt, *args):
    msg = fmt % args
    sys.stderr.write(prog + ": " + msg)
    
def fatal(fmt, *args):
    msg = fmt % args
    sys.stderr.write(prog + ": " + msg)
    sys.exit(1)

if len(sys.argv) < 2:
    fatal("must specify a type\n")
TYPE_ARG = sys.argv[1]

dev_dict = None
if len(sys.argv) > 2 and sys.argv[2] != '-':
    dev_dict = {}
    for dev in sys.argv[2].split(','):
        dev_dict[dev] = True

def skip_type(type):
    return type != TYPE_ARG

def skip_dev(type, dev):
    return type != TYPE_ARG or (dev_dict and dev not in dev_dict)

KEY_LIST = None
if len(sys.argv) > 3:
    KEY_LIST = sys.argv[3:]

# Read header.
schema_def = None
for line in stats_file:
    rec = line.split()
    if len(rec) == 0:
        break # end_header()
    elif rec[0][0].isalnum():
        break # Invalid.
    elif rec[0] == SF_SCHEMA_CHAR + TYPE_ARG:
        schema_def = rec[1:]
    elif rec[0][0] == SF_PROPERTY_CHAR:
        header_props[rec[0][1:]] = string.join(rec[1:])

hostname = header_props.get("hostname", "-")
if opt_short_hostname:
    hostname = hostname.split(".")[0]

if not schema_def:
    fatal("unknown type `%s'\n", TYPE_ARG)

def format_size(v, u):
    if not opt_format_size:
        return (v, "")
    m = ""
    if abs(v) >= 1L << 30:
        v /= 1L << 30 
        m = 'G'
    elif abs(v) >= 1L << 20:
        v /= 1L << 20
        m = 'M'
    elif abs(v) >= 1L << 10:
        v /= 1L << 10
        m = 'K'
    return (v, m + u)

def parse_size(str):
    v = 1.0
    i = 0
    while str[i].isdigit() or str[i] == '.':
        i = i + 1
    if i > 0:
        v = float(str[0:i])
    if str[i] == 'G':
        v *= 1L << 30
        i += 1
    elif str[i] == 'M':
        v *= 1L << 20
        i += 1
    elif str[i] == 'K':
        v *= 1L << 10
        i += 1
    elif str[i] == 'c':
        v /= 100.0
        i += 1
    elif str[i] == 'm':
        v /= 1000.0
        i += 1
    return (v, str[i:])

class SchemaEnt:
    def __init__(self, ent_def):
        lis = ent_def.split(',')
        self.key = lis[0]
        self.event = False
        self.control = False
        self.width = None
        self.mult = 1.0
        self.unit = ""
        for opt in lis[1:]:
            if len(opt) == 0:
                continue
            elif opt[0] == 'C':
                self.control = True
            elif opt[0] == 'E':
                self.event = True
            elif opt[0:2] == 'W=':
                self.width = int(opt[2:])
            elif opt[0:2] == 'U=':
                (self.mult, self.unit) = parse_size(opt[2:])
            else:
                error("unrecognized option `%s'\n", opt)
    def format(self, v0, v1, t0, t1):
        if self.control:
            return (v1, "")
        elif self.event:
            ve = 0.0
            if t0 != 0L:
                # Check for rollover.
                if v1 < v0:
                    if self.width:
                        v0 -= 1L << self.width
                    else:
                        error("full width rollover at time %s, key `%s', v0 %u, v1 %u\n",
                              curr_time_str, self.key, v0, v1)
                ve = self.mult * float(v1 - v0) / (t1 - t0)
            return format_size(ve, self.unit)
        else:
            return format_size(v1 * self.mult, self.unit)

schema_len = 0
schema_ent = []
schema_dict = {}
for ent_def in schema_def:
    ent = SchemaEnt(ent_def)
    schema_ent.insert(schema_len, ent)
    schema_dict[ent.key] = schema_len
    schema_len += 1

if KEY_LIST:
    index_list = []
    for key in KEY_LIST:
        i = schema_dict.get(key, None)
        if not i:
            # Try to get a good partial match.
            match_list = []
            for (s_key, s_index) in schema_dict.iteritems():
                if s_key[0:len(key)] == key:
                    i = s_index
                    match_list.append(s_key)
            if len(match_list) == 0:
                fatal("unrecognized key `%s'\n", key)
            elif len(match_list) > 1:
                fatal("ambiguous key specification `%s': possible completions are `%s'\n",
                      key, string.join(match_list, ", "))
        index_list.append(i)
else:
    index_list = range(0, schema_len)

trace("type: `%s'\n", TYPE_ARG)
trace("dev_dict: %s\n", dev_dict)
trace("key_list: %s\n", KEY_LIST)
trace("schema_ent: %s\n", schema_ent)
trace("schema_dict: %s\n", schema_dict)
trace("index_list: %s\n", index_list)

curr_time = 0L
curr_time_str = time.strftime(time_fmt, time.localtime(curr_time))
curr_jobid = "-"
prev_time_dict = {}
prev_vals_dict = {}

def emit_prefix(type, dev):
    print "%s\t%s\t%s\t%s" % (curr_time_str, curr_jobid, hostname, dev),

def handle_stats(stype, rest):
    if skip_type(stype):
        return
    if len(rest) != schema_len + 1:
        error("short record `%s' %s\n", stype, rest)
        return
    if curr_time == 0L:
        error("no timestamp for record `%s' %s\n", stype, rest)
        return
    dev = rest[0]
    if skip_dev(stype, dev):
        return
    t0 = prev_time_dict.get(dev, 0L)
    t1 = curr_time
    prev_vals = prev_vals_dict.get(dev, schema_len * [ 0L ])
    curr_vals = map(long, rest[1:])
    if t0 < t1:
        emit_prefix(stype, dev)
        for i in index_list:
            (v, u) = schema_ent[i].format(prev_vals[i], curr_vals[i], t0, t1)
            # print "%10.3f %-2s" % (v, u),
            print "\t%d" % (long(v),),
        print
    prev_time_dict[dev] = curr_time
    prev_vals_dict[dev] = curr_vals

def handle_mark(str, rest):
    if opt_print_mark:
        print "%s MARK %s %s" % (curr_time_str, str, string.join(rest))

# Read data.
for line in stats_file:
    if line.isspace():
        # End group.
        continue
    rec = line.split()
    c = rec[0][0]
    if c.isdigit():
        # Begin group.
        curr_time = long(rec[0])
        curr_time_str = time.strftime(time_fmt, time.localtime(curr_time))
        # TODO jobid.
        if len(rec) > 1:
            curr_jobid = rec[1]
    elif c.isalpha():
        handle_stats(rec[0], rec[1:])
    elif c == SF_COMMENT_CHAR:
        pass
    elif c == SF_MARK_CHAR:
        handle_mark(rec[0][1:], rec[1:])
    else:
        # Invalid record.
        pass
